#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <ctime>
#include <cstdlib>

const int Empty = 0;
const int Mine = -1;
const int Flagged = -2;

class Cell {
public:
    int value;  // Значение клетки: Mine, Empty или Flagged
    bool open;  // Открыта ли клетка
    bool flagged; // Помечена ли клетка флагом

    Cell() : value(Empty), open(false), flagged(false) {}
};

class Board {
public:
    std::vector<std::vector<Cell>> cells;
    int width, height, mines;
    int flaggedMines;  // Количество правильно помеченных мин
    bool firstClick;
    bool gameOver;  // Флаг окончания игры

    Board(int width, int height, int mines)
        : width(width), height(height), mines(mines), flaggedMines(0), firstClick(true), gameOver(false) {
        cells.resize(height, std::vector<Cell>(width));
    }

    void generate(int x, int y) {
        srand(time(0));

        // Генерация мин, избегая клетки, на которой был первый клик
        for (int i = 0; i < mines; ++i) {
            int xx, yy;
            do {
                xx = rand() % width;
                yy = rand() % height;
            } while ((xx == x && yy == y) || cells[yy][xx].value == Mine);
            cells[yy][xx].value = Mine;
            incrementAdjacentCells(xx, yy);
        }
        firstClick = false;
    }

    void incrementAdjacentCells(int x, int y) {
        for (int i = -1; i <= 1; ++i) {
            for (int j = -1; j <= 1; ++j) {
                if (i == 0 && j == 0) continue;
                int adjX = x + j, adjY = y + i;
                if (adjX >= 0 && adjX < width && adjY >= 0 && adjY < height && cells[adjY][adjX].value != Mine) {
                    cells[adjY][adjX].value++;
                }
            }
        }
    }

    void openCell(int x, int y) {
        if (cells[y][x].open || gameOver) return; // Если клетка уже открыта или игра закончена

        cells[y][x].open = true;

        if (cells[y][x].value == Mine) {
            gameOver = true;  // Игра завершена, если попали на мину
        }
    }

    void flagCell(int x, int y) {
        if (!cells[y][x].open && !gameOver) {
            cells[y][x].flagged = !cells[y][x].flagged;

            // Если флаг был поставлен на мину, увеличиваем счётчик найденных мин
            if (cells[y][x].value == Mine && cells[y][x].flagged) {
                flaggedMines++;
            }
            // Если флаг убран с мины, уменьшаем счётчик найденных мин
            else if (cells[y][x].value == Mine && !cells[y][x].flagged) {
                flaggedMines--;
            }
        }
    }

    void display(sf::RenderWindow &window, sf::Time elapsedTime) {
        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                auto &cell = cells[y][x];
                sf::RectangleShape cellShape(sf::Vector2f(30.f, 30.f));
                cellShape.setPosition(x * 30.f, y * 30.f);
                
                if (cell.open) {
                    if (cell.value == Mine) {
                        cellShape.setFillColor(sf::Color::Red); // Мин
                    } else {
                        cellShape.setFillColor(sf::Color::White); // Пустая клетка
                    }
                } else {
                    cellShape.setFillColor(sf::Color(169, 169, 169)); // Закрытая клетка
                }
                
                window.draw(cellShape);

                // Отображение флага
                if (cell.flagged) {
                    sf::CircleShape flagShape(10.f, 3);
                    flagShape.setPosition(x * 30.f + 7.f, y * 30.f + 7.f);
                    flagShape.setFillColor(sf::Color::Blue);
                    window.draw(flagShape);
                }
                
                if (cell.open && cell.value > 0) {
                    sf::Text text;
                    text.setFont(font);
                    text.setString(std::to_string(cell.value));
                    text.setCharacterSize(18);
                    text.setFillColor(sf::Color::Black);
                    text.setPosition(x * 30.f + 10.f, y * 30.f + 5.f);
                    window.draw(text);
                }
            }
        }

        // Если игра окончена (поражение)
        if (gameOver) {
            sf::Text gameOverText;
            gameOverText.setFont(font);
            gameOverText.setString("Game Over!");
            gameOverText.setCharacterSize(50);
            gameOverText.setFillColor(sf::Color::Red);
            gameOverText.setPosition(width * 15.f / 2, height * 15.f / 2);
            window.draw(gameOverText);

            // Показать статистику о мин
            sf::Text statsText;
            statsText.setFont(font);
            statsText.setString("Mines found: " + std::to_string(flaggedMines) + "/" + std::to_string(mines));
            statsText.setCharacterSize(20);
            statsText.setFillColor(sf::Color::Black);
            statsText.setPosition(10.f, height * 30.f - 30.f);
            window.draw(statsText);
        }

        // Отображаем таймер
        sf::Text timerText;
        timerText.setFont(font);
        timerText.setString("Time: " + std::to_string(elapsedTime.asSeconds()) + "s");
        timerText.setCharacterSize(20);
        timerText.setFillColor(sf::Color::Black);
        timerText.setPosition(10.f, 10.f);
        window.draw(timerText);
    }

    static sf::Font font;
    static bool fontLoaded;
};

sf::Font Board::font;
bool Board::fontLoaded = false;

class GameWindow : public sf::RenderWindow {
public:
    GameWindow(int width, int height) : sf::RenderWindow(sf::VideoMode(width * 30, height * 30), "Minesweeper") {
        // Убираем вертикальную синхронизацию
        setVerticalSyncEnabled(false); // Можно убрать или оставить, если драйвер поддерживает

        // Загрузка шрифта, теперь используем доступный шрифт или по умолчанию
        if (!Board::fontLoaded) {
            Board::fontLoaded = Board::font.loadFromFile("arial.ttf"); // Используем стандартный Arial, если sansation.ttf не доступен
            if (!Board::fontLoaded) {
                std::cerr << "Error: Could not load font!" << std::endl;
                return;
            }
        }
    }

    void runGame() {
        int width, height, mines;
        std::cout << "Enter board width: ";
        std::cin >> width;
        std::cout << "Enter board height: ";
        std::cin >> height;
        std::cout << "Enter number of mines: ";
        std::cin >> mines;

        if (mines >= width * height) {
            std::cerr << "Error: Too many mines!" << std::endl;
            return;
        }

        Board board(width, height, mines); // Создаём поле с заданными параметрами
        bool gameOver = false;

        sf::Clock clock;
        sf::Time elapsedTime;

        while (isOpen() && !board.gameOver) {
            sf::Event event;
            while (pollEvent(event)) {
                if (event.type == sf::Event::Closed) {
                    close();
                }

                if (event.type == sf::Event::MouseButtonPressed) {
                    int x = event.mouseButton.x / 30;
                    int y = event.mouseButton.y / 30;

                    if (event.mouseButton.button == sf::Mouse::Left) {
                        if (board.firstClick) {
                            board.generate(x, y);
                        }
                        board.openCell(x, y);
                    } else if (event.mouseButton.button == sf::Mouse::Right) {
                        board.flagCell(x, y);
                    }
                }
            }

            // Получаем время, прошедшее с начала игры
            elapsedTime = clock.getElapsedTime();

            clear(sf::Color::White);
            board.display(*this, elapsedTime);

            display();
        }
    }
};

int main() {
    GameWindow window(20, 20); // Используем маленький размер поля для теста
    window.runGame();
    return 0;
}
